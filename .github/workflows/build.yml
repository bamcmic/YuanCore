name: Build Kernel -> .bin

on:
  workflow_dispatch:
    inputs:
      source_folder:
        description: "Source folder name (e.g., 0.001bate)"
        required: true
        default: "0.001bate"

jobs:
  build:
    runs-on: ubuntu-latest
    name: Build kernel -> .bin

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install required packages
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends gcc-multilib binutils

      - name: Prepare paths
        id: prep
        run: |
          SRC="source code/Commented code/C source code/${{ github.event.inputs.source_folder }}"
          OUT="Assembly_section/x86_64/${{ github.event.inputs.source_folder }}"
          mkdir -p "$OUT"
          echo "src_dir=$SRC" >> $GITHUB_OUTPUT
          echo "out_dir=$OUT" >> $GITHUB_OUTPUT

      - name: Build .bin
        id: build
        shell: bash
        run: |
          set -euo pipefail
          SRC="${{ steps.prep.outputs.src_dir }}"
          OUT="${{ steps.prep.outputs.out_dir }}"
          cd "$SRC"

          # 检查 boot.s
          if [ ! -f boot.s ]; then
            echo "ERROR: boot.s not found in $SRC"
            exit 1
          fi

          # 自动检测 32/64 位
          BITNESS=64
          if grep -q -E '^\s*BITS\s+32\b' boot.s || grep -q -E '(%esp|%eax|movl|int \$0x80|pushl)' boot.s; then
            BITNESS=32
          fi
          echo "Detected bitness: $BITNESS"

          # 清理旧文件
          rm -f boot.o kernel.o kernel.bin

          # 编译 boot.s
          if [ "$BITNESS" = "32" ]; then
            gcc -c -m32 boot.s -o boot.o
          else
            gcc -c -m64 boot.s -o boot.o
          fi

          # 编译 kernel.c（如果存在）
          OBJS="boot.o"
          if [ -f kernel.c ]; then
            if [ "$BITNESS" = "32" ]; then
              gcc -ffreestanding -c -m32 kernel.c -o kernel.o
            else
              gcc -ffreestanding -c -m64 kernel.c -o kernel.o
            fi
            OBJS="$OBJS kernel.o"
          fi

          # 链接生成 bin
          LD_MODE=$([ "$BITNESS" = "32" ] && echo elf_i386 || echo elf_x86_64)
          ld -m $LD_MODE -T linker.ld -o kernel.elf $OBJS
          objcopy -O binary kernel.elf kernel.bin

          # 拷贝到输出目录
          cp kernel.bin "$OUT/kernel.bin"
          echo "kernel.bin created in $OUT"

          # 列出输出文件，确保存在
          ls -l "$OUT"

      - name: Upload artifact (bin)
        uses: actions/upload-artifact@v4
        with:
          name: kernel-bin
          path: ${{ steps.prep.outputs.out_dir }}/kernel.bin
