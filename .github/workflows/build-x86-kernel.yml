name: Build x86 YuanCore Kernel

on:
  workflow_dispatch:
    inputs:
      version:
        description: source code/Commented code/C source code/0.001bate 'è¦ç¼–è¯‘çš„ç‰ˆæœ¬ç›®å½• (ä¾‹å¦‚: 0.001)'
        required: false
        default: 'latest'
        type: string
      clean-build:
        description: 'æ¸…ç†ä¹‹å‰çš„æž„å»º'
        required: false
        default: true
        type: boolean

jobs:
  build-kernel:
    runs-on: ubuntu-latest
    env:
      OUTPUT_DIR: "Assembly section/x86_64"
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Determine version to compile
      id: version-select
      run: |
        if [ "${{ github.event.inputs.version }}" = "latest" ] || [ -z "${{ github.event.inputs.version }}" ]; then
          echo "Finding latest version..."
          cd "source code/Commented code/C source code"
          
          # æŸ¥æ‰¾æ‰€æœ‰ç‰ˆæœ¬æ–‡ä»¶å¤¹å¹¶æŒ‰ç‰ˆæœ¬å·æŽ’åº
          VERSION=$(find . -maxdepth 1 -type d -name '*.*.*' 2>/dev/null | sed 's|./||' | sort -V | tail -n1)
          
          if [ -z "$VERSION" ]; then
            # å¦‚æžœæ²¡æœ‰æ‰¾åˆ°x.x.xæ ¼å¼çš„ç‰ˆæœ¬ï¼ŒæŸ¥æ‰¾å…¶ä»–æ•°å­—ç‰ˆæœ¬
            VERSION=$(find . -maxdepth 1 -type d -name '[0-9]*' 2>/dev/null | sed 's|./||' | sort -V | tail -n1)
          fi
          
          if [ -z "$VERSION" ]; then
            # å¦‚æžœè¿˜æ˜¯æ²¡æœ‰æ‰¾åˆ°ï¼Œä½¿ç”¨å½“å‰ç›®å½•
            VERSION="."
            echo "No version directories found, using current directory"
          fi
        else
          VERSION="${{ github.event.inputs.version }}"
        fi
        
        echo "Selected version: $VERSION"
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Install build dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          gcc-multilib \
          nasm \
          grub-pc-bin \
          xorriso \
          qemu-system-x86

    - name: Clean previous build (if requested)
      if: inputs.clean-build
      run: |
        echo "Cleaning previous build directory..."
        rm -rf "$OUTPUT_DIR/${{ steps.version-select.outputs.version }}" || true
        mkdir -p "$OUTPUT_DIR/${{ steps.version-select.outputs.version }}"

    - name: Create output directory
      run: |
        mkdir -p "$OUTPUT_DIR/${{ steps.version-select.outputs.version }}"
        echo "Output directory: $OUTPUT_DIR/${{ steps.version-select.outputs.version }}"

    - name: Detect source files
      id: detect-files
      run: |
        SOURCE_DIR="source code/Commented code/C source code/${{ steps.version-select.outputs.version }}"
        echo "Source directory: $SOURCE_DIR"
        
        # æ£€æŸ¥å¿…è¦çš„æºæ–‡ä»¶
        if [ -f "$SOURCE_DIR/kernel.c" ]; then
          echo "âœ“ Found kernel.c"
          echo "has_kernel_c=true" >> $GITHUB_OUTPUT
        else
          echo "âœ— Missing kernel.c"
          echo "has_kernel_c=false" >> $GITHUB_OUTPUT
        fi
        
        if [ -f "$SOURCE_DIR/boot.s" ]; then
          echo "âœ“ Found boot.s"
          echo "has_boot_s=true" >> $GITHUB_OUTPUT
        else
          echo "âœ— Missing boot.s"
          echo "has_boot_s=false" >> $GITHUB_OUTPUT
        fi
        
        if [ -f "$SOURCE_DIR/linker.ld" ]; then
          echo "âœ“ Found linker.ld"
          echo "has_linker=true" >> $GITHUB_OUTPUT
        else
          echo "âœ— Missing linker.ld"
          echo "has_linker=false" >> $GITHUB_OUTPUT
        fi

    - name: Create missing files
      if: steps.detect-files.outputs.has_kernel_c == 'false' || steps.detect-files.outputs.has_boot_s == 'false' || steps.detect-files.outputs.has_linker == 'false'
      run: |
        SOURCE_DIR="source code/Commented code/C source code/${{ steps.version-select.outputs.version }}"
        mkdir -p "$SOURCE_DIR"
        
        # å¦‚æžœç¼ºå°‘ kernel.cï¼Œåˆ›å»ºå®ƒ
        if [ "${{ steps.detect-files.outputs.has_kernel_c }}" = "false" ]; then
          cat > "$SOURCE_DIR/kernel.c" << 'EOF'
/* YuanCore x86 å¾®å†…æ ¸ - æ‰“å° "YuanCore" */

#define VIDEO_MEMORY 0xB8000
#define SCREEN_WIDTH 80
#define SCREEN_HEIGHT 25
#define WHITE_ON_BLACK 0x0F

static inline void outb(unsigned short port, unsigned char value) {
    asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
}

static inline unsigned char inb(unsigned short port) {
    unsigned char value;
    asm volatile ("inb %1, %0" : "=a"(value) : "Nd"(port));
    return value;
}

void enable_cursor(unsigned char cursor_start, unsigned char cursor_end) {
    outb(0x3D4, 0x0A);
    outb(0x3D5, (inb(0x3D5) & 0xC0) | cursor_start);
    
    outb(0x3D4, 0x0B);
    outb(0x3D5, (inb(0x3D5) & 0xE0) | cursor_end);
}

void update_cursor(int x, int y) {
    unsigned short pos = y * SCREEN_WIDTH + x;
    
    outb(0x3D4, 0x0F);
    outb(0x3D5, (unsigned char)(pos & 0xFF));
    outb(0x3D4, 0x0E);
    outb(0x3D5, (unsigned char)((pos >> 8) & 0xFF));
}

void clear_screen() {
    char *video_memory = (char*)VIDEO_MEMORY;
    for (int i = 0; i < SCREEN_WIDTH * SCREEN_HEIGHT * 2; i += 2) {
        video_memory[i] = ' ';
        video_memory[i + 1] = WHITE_ON_BLACK;
    }
}

void print_string(const char *str, int x, int y) {
    char *video_memory = (char*)VIDEO_MEMORY;
    int offset = (y * SCREEN_WIDTH + x) * 2;
    
    for (int i = 0; str[i] != '\0'; i++) {
        video_memory[offset] = str[i];
        video_memory[offset + 1] = WHITE_ON_BLACK;
        offset += 2;
    }
}

void kernel_main() {
    enable_cursor(14, 15);
    clear_screen();
    
    const char *message = "YuanCore";
    int message_len = 0;
    while (message[message_len] != '\0') message_len++;
    
    int x = (SCREEN_WIDTH - message_len) / 2;
    int y = SCREEN_HEIGHT / 2;
    
    print_string(message, x, y);
    update_cursor(x + message_len, y);
    
    while (1) {
        asm volatile ("hlt");
    }
}
EOF
          echo "Created kernel.c"
        fi

        # å¦‚æžœç¼ºå°‘ boot.sï¼Œåˆ›å»ºå®ƒ
        if [ "${{ steps.detect-files.outputs.has_boot_s }}" = "false" ]; then
          cat > "$SOURCE_DIR/boot.s" << 'EOF'
.set ALIGN,    1<<0
.set MEMINFO,  1<<1
.set FLAGS,    ALIGN | MEMINFO
.set MAGIC,    0x1BADB002
.set CHECKSUM, -(MAGIC + FLAGS)

.section .multiboot
.align 4
.long MAGIC
.long FLAGS
.long CHECKSUM

.section .bss
.align 16
stack_bottom:
.skip 16384
stack_top:

.section .text
.global _start
.type _start, @function

_start:
    mov $stack_top, %esp
    call kernel_main
    cli
1:  hlt
    jmp 1b

.size _start, . - _start
EOF
          echo "Created boot.s"
        fi

        # å¦‚æžœç¼ºå°‘ linker.ldï¼Œåˆ›å»ºå®ƒ
        if [ "${{ steps.detect-files.outputs.has_linker }}" = "false" ]; then
          cat > "$SOURCE_DIR/linker.ld" << 'EOF'
ENTRY(_start)

SECTIONS
{
    . = 1M;

    .text BLOCK(4K) : ALIGN(4K)
    {
        *(.multiboot)
        *(.text)
    }

    .rodata BLOCK(4K) : ALIGN(4K)
    {
        *(.rodata)
    }

    .data BLOCK(4K) : ALIGN(4K)
    {
        *(.data)
    }

    .bss BLOCK(4K) : ALIGN(4K)
    {
        *(COMMON)
        *(.bss)
    }
}
EOF
          echo "Created linker.ld"
        fi

    - name: Build x86 kernel
      id: build
      run: |
        SOURCE_DIR="source code/Commented code/C source code/${{ steps.version-select.outputs.version }}"
        BUILD_DIR="$OUTPUT_DIR/${{ steps.version-select.outputs.version }}"
        
        cd "$SOURCE_DIR"
        
        echo "Building x86 kernel from $SOURCE_DIR..."
        
        # ç¼–è¯‘å¼•å¯¼æ±‡ç¼–ä»£ç 
        as --32 boot.s -o boot.o
        echo "âœ“ Compiled boot.s"
        
        # ç¼–è¯‘å†…æ ¸Cä»£ç 
        gcc -m32 -ffreestanding -nostdlib -nostartfiles -c kernel.c -o kernel.o
        echo "âœ“ Compiled kernel.c"
        
        # é“¾æŽ¥å†…æ ¸
        ld -m elf_i386 -T linker.ld -o "$BUILD_DIR/yuancore.bin" boot.o kernel.o
        echo "âœ“ Linked kernel"
        
        # æ£€æŸ¥æ–‡ä»¶å¤§å°
        size=$(stat -c%s "$BUILD_DIR/yuancore.bin")
        echo "Kernel size: $((size / 1024)) KB"
        echo "kernel_size=$size" >> $GITHUB_OUTPUT

    - name: Test kernel with QEMU (quick test)
      run: |
        BUILD_DIR="$OUTPUT_DIR/${{ steps.version-select.outputs.version }}"
        
        # å¿«é€Ÿæµ‹è¯•å†…æ ¸æ˜¯å¦èƒ½è¢«QEMUåŠ è½½ï¼ˆä¸æ˜¾ç¤ºå›¾å½¢ç•Œé¢ï¼‰
        timeout 10s qemu-system-x86_64 \
          -kernel "$BUILD_DIR/yuancore.bin" \
          -display none \
          -serial stdio \
          -monitor none || true
        echo "âœ“ Kernel test completed"

    - name: List build artifacts
      run: |
        BUILD_DIR="$OUTPUT_DIR/${{ steps.version-select.outputs.version }}"
        echo "=== Build Artifacts ==="
        ls -la "$BUILD_DIR"
        echo ""
        echo "Kernel file: $(ls -sh "$BUILD_DIR/yuancore.bin")"

    - name: Upload kernel binary
      uses: actions/upload-artifact@v4
      with:
        name: yuancore-kernel-${{ steps.version-select.outputs.version }}
        path: Assembly section/x86_64/${{ steps.version-select.outputs.version }}/yuancore.bin
        retention-days: 30

    - name: Create build summary
      run: |
        echo "## ðŸŽ‰ YuanCore x86 Kernel æž„å»ºå®Œæˆ!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**ç‰ˆæœ¬:** ${{ steps.version-select.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "**æž¶æž„:** x86_64" >> $GITHUB_STEP_SUMMARY
        echo "**å†…æ ¸å¤§å°:** ${{ steps.build.outputs.kernel_size }} å­—èŠ‚ ($(({{ steps.build.outputs.kernel_size }} / 1024)) KB)" >> $GITHUB_STEP_SUMMARY
        echo "**è¾“å‡ºç›®å½•:** \`Assembly section/x86_64/${{ steps.version-select.outputs.version }}/\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“ ç”Ÿæˆçš„æ–‡ä»¶:" >> $GITHUB_STEP_SUMMARY
        echo "- \`yuancore.bin\` - x86 å¯æ‰§è¡Œå†…æ ¸" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”§ æµ‹è¯•å‘½ä»¤:" >> $GITHUB_STEP_SUMMARY
        echo '```bash' >> $GITHUB_STEP_SUMMARY
        echo "qemu-system-x86_64 -kernel Assembly section/x86_64/${{ steps.version-select.outputs.version }}/yuancore.bin" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY